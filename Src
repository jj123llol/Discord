'''

to get started install discord.py-self, and uwuipy

if you use any code from here, credit me!!
iused discord.py docs!

'''

import discord, os, time, asyncio, random, requests
from uwuipy import Uwuipy



print("---[[[[  loading, wait until done. ]]]]---\n\n\n")
if not os.path.exists("token.txt"):
    token = input("token: ")
    with open("token.txt", "w") as f:
        f.write(token)
    
with open("token.txt", "r") as f:
    token = f.read()

global prefix, others_allowed, loaded, watching, whitelisted, spam_ping, cmdlists, bot_runner, afk
prefix, others_allowed = ".", True
afk = {}
loaded, spam_ping = False, False
watching = []
whitelisted = []
bot_runner = ""

cmds = {}
cmdlists = {}

async def getImg(url):
    if os.path.exists("temp.png"):
        os.remove("temp.png")
    img_data = requests.get(url).content
    with open('temp.png', 'wb') as file:
        file.write(img_data)
    file = discord.File("temp.png")
    return file
    
    
async def getGif(url):
    if os.path.exists("temp.gif"):
        os.remove("temp.gif")
    img_data = requests.get(url).content
    with open('temp.gif', 'wb') as file:
        file.write(img_data)
    file = discord.File("temp.gif")
    return file

async def tick():
    unix = time.time()
    unix = str(unix)
    unix = unix.split(".")[0]
    return int(unix)
   

class cmdlist:
    async def update(self):
        temp_list = []
        for cmd in cmds:
            temp_list.append(cmds[cmd]["list"])
        temp_list = temp_list[self.minn:self.maxx]
        self.comds = "\n".join(temp_list)
        await self.message.edit(self.comds + "\n\n react ‚ñ∂Ô∏è or ‚óÄÔ∏è or ‚ùå")
    async def start(self, channel):
        global cmdlists
        self.message = await channel.send("loading..")
        self.minn = 0
        self.maxx = 5
        await self.update()
        cmdlists[self.message] = self
        return self.message
    async def next(self):
        self.minn = self.minn + 5
        self.maxx = self.maxx + 5
        if self.minn > len(cmds):
            self.minn = 0
            self.maxx = 5
        await self.update()
        
    async def back(self):
        self.minn = self.minn - 5
        self.maxx = self.maxx - 5
        if self.minn < 0:
            self.minn = 0
            self.maxx = 5
        await self.update()
        
    async def delete(self):
        await self.message.delete()
        del cmdlists[self.message]

def addcmd(name, level, lis):
    def decorator(func):
        cmds[name] = {
            "func": func,
            "level": level,
            "list": lis
        }
        return func
    return decorator
    
async def waitForReaction(emote, target, msg):
    def check(reaction, user):
        return user.id == target.id and str(reaction.emoji) == emote and msg == reaction.message

    try:
        reaction, user = await client.wait_for('reaction_add', timeout=30.0, check=check)
    except asyncio.TimeoutError:
        return False
    else:
        return True
            
            
@addcmd("ping", 1, "ping")
async def ping(msg, message, self):
    await message.reply(f"hello, <@{message.author.id}>. pong!")

@addcmd("insult", 1, "insult @someone")
async def insult(msg, message, self):
    for mention in message.mentions:
        insults = ["smells bad", "looks bad", "is a horrible friend"]
        await message.channel.send(f"<@{mention.id}> " + insults[random.randint(0, len(insults)-1)])
    
        
@addcmd("compliment", 1, "compliment @someone")
async def compliment(msg, message, self):
    for mention in message.mentions:
        comps = ["looks good", "smells good", "is a good friend", "is pretty"]
        await message.channel.send(f"<@{mention.id}> " + comps[random.randint(0, len(comps)-1)])
    
        
@addcmd("afk", 1, "afk (reason)")
async def afkz(msg, message, self):
    global afk
    if message.author.id in afk:
        await message.reply("no longer afk")
        del afk[message.author.id]
        return ""
    unix = str(await tick())
    msg = " ".join(msg)
    msg = msg + f"\nafking since: <t:{unix}:R>"
    afk[message.author.id] = msg
    await message.reply(f"afking for {msg}")

@addcmd("unafk", 1, "unafk")
async def unafk(msg, message, self):
    global afk
    try:
        del afk[message.author.id]
        await message.reply("afk off")
    except:
        await message.reply("failed")

@addcmd("disclaimer", 1, "disclaimer")        
async def disclaimer(msg, message, seld):
    await message.reply("this is not a selfbot, im manually replying")

@addcmd("setprefix", 2, "setprefix (prefix)")  
async def setprefix(msg, message, self):
    global prefix
    prefix = msg[0]
    await message.edit(f"prefix changed to `{prefix}`")

    
@addcmd("ghostping", 1, "ghostping @someone")            
async def ghostping(msg, message, self):
    mentions = message.mentions
    try:
        await message.delete()
    except:
        await message.reply("cant delete msg")
    for mention in mentions:
        sent = await message.channel.send(f"<@{mention.id}> ping!")
        time.sleep(1)
        await sent.delete()
       

@addcmd("sex", 1, "sex @someone")              
async def sex(msg, message, self):
    for mention in message.mentions:
        new_msg = await message.channel.send(f"<@{mention.id}>, do you wanna have sex with <@{message.author.id}>? react with üëç if yes. no reaction within 30 seconds means no.")
        consent = await waitForReaction('üëç', mention, new_msg)
        if consent == False:
            await message.reply(f'rizz-quirements not met, <@{message.author.id}> has no rizz!:broken_heart:')
            await new_msg.delete()
        else:
            await message.reply(f' <@{message.author.id}> sucessfully fucked <@{mention.id}>!:tongue:')
            await new_msg.delete()
            
@addcmd("date", 1, "date @someone")              
async def date(msg, message, self):
    for mention in message.mentions:
        new_msg = await message.channel.send(f"<@{mention.id}>,  <@{message.author.id}> asks you on a date! do you agree? react with üëç if yes. no reaction within 30 seconds means no.")
        consent = await waitForReaction('üëç', mention, new_msg)
        if consent == False:
            await message.reply(f'rizz-quirements not met, <@{message.author.id}> has no rizz!:broken_heart:')
            await new_msg.delete()
        else:
            await message.reply(f' <@{message.author.id}> sucessfully had a date with <@{mention.id}>:rose:!')
            await new_msg.delete()
  
            
@addcmd("cuddle", 1, "cuddle @someone")           
async def cuddle(msg, message, self):
    for mention in message.mentions:
        new_msg = await message.channel.send(f"<@{mention.id}>,  <@{message.author.id}> asks you to cuddle! do you agree? react with üëç if yes. no reaction within 30 seconds means no.")
        consent = await waitForReaction('üëç', mention, new_msg)
        if consent == False:
            await message.reply(f'rizz-quirements not met, <@{message.author.id}> has no rizz!:broken_heart:')
            await new_msg.delete()
        else:
            await message.reply(f' <@{message.author.id}> and <@{mention.id}> cuddled! :people_hugging::heart:!')
            await new_msg.delete()         
                 
                           
@addcmd("blow", 1, "blow @someone")              
async def vloe(msg, message, self):
    for mention in message.mentions:
        new_msg = await message.channel.send(f"<@{mention.id}>, do you wanna be blown by <@{message.author.id}>? react with üëç if yes. no reaction within 30 seconds means no.")
        consent = await waitForReaction('üëç', mention, new_msg)
        if consent == False:
            await message.reply(f'rizz-quirements not met, <@{message.author.id}> has no rizz!:broken_heart:')
            await new_msg.delete()
        else:
            await new_msg.edit("processing..")
            imgs = [
            "https://raw.githubusercontent.com/jj123llol/Discord/refs/heads/main/Screenshot_20250724-001001-813.png",
            "https://raw.githubusercontent.com/jj123llol/Discord/refs/heads/main/Screenshot_20250724-012440-666.png"
            ]
            picture = await getImg(imgs[random.randint(0, len(imgs)-1)])
            try:
                await message.reply(f' <@{message.author.id}> sucessfully sucked off <@{mention.id}>!', file=picture)
            except:
                await message.reply(f' <@{message.author.id}> sucessfully sucked off <@{mention.id}>!')
            await new_msg.delete()
            
            
@addcmd("cat", 1, "cat")
async def cat(msg, message, self):
    msg = await message.channel.send("sending..(time depends on internet)")
    cat = await getImg("https://cataas.com/cat")
    await message.reply("Meow :cat:!", file=cat)
    await msg.delete()

@addcmd("multicat", 1, "multicat")
async def multicat(msg, message, self):
    msg = await message.channel.send("sending..this may take a minute.. (time depends on internet)")
    cats = []
    i = 0
    while i != 10:
        i = i + 1
        cats.append(await getImg("https://cataas.com/cat"))
    try:
        await message.reply("Meow :cat:!", files=cats)
    except:
        await message.reply("failed to send!")
    await msg.delete()
    
@addcmd("catgif", 1, "catgif")
async def catgif(msg, message, self):
    msg = await message.channel.send("sending..(time depends on internet)")
    cat = await getGif("https://cataas.com/cat/gif")
    try:
        await message.reply("Meow :cat:!", file=cat)
    except:
        await message.reply("failed to send!")
    await msg.delete()
    
@addcmd("currentsong", 1, "currentsong")
async def currentsong(msg, message, self):
    mention = None
    if len(message.mentions) > 0:
        mention = message.mentions[0].id     
    if mention != None:
        id = mention
    else:
        id = message.author.id
    person = None
    try:
        person = await message.channel.guild.fetch_member(id)
    except:
        person = self.get_relationship(id)
    if person == None:
        await message.reply("failed to get activity")
        return ""
    activitities = person.activities
    found = False
    for activ in activitities:
        if str(activ) == "Spotify":
            found = True
            artists = ", ".join(activ.artists)
            await message.reply(activ.album_cover_url)
            time.sleep(.5)
            await message.channel.send(f"album: {activ.album}\nsong: {activ.title}\nurl: {activ.track_url}\nartists: {artists}")
    if found == False:
        await message.reply("failed to find spotify activity")
        
@addcmd("gif", 1, "gif (img)")
async def gif(msg, message, self):
    msg = await message.reply("give us a second!")
    try:
        attach = message.attachments[0]
        file = await getGif(attach.url)
        await message.reply(files=[file])
        await msg.delete()
    except:
        await msg.edit("failed!")
    
@addcmd("avatar", 1, "avatar @someone")
async def avatar(msg, message, self):
    avatars = []
    msg = await message.reply("give us a second!")
    for mention in message.mentions:
        id = mention.id
        mention = await self.fetch_user_profile(mention.id)
        if mention.display_avatar == None:
            await message.reply(f"<@{id}> has no avatar")
            continue
        if mention.display_avatar.url.find(".gif"):
            avatars.append(await getGif(mention.display_avatar.url))
        else:
            avatars.append(await getImg(mention.display_avatar.url))
    await msg.delete()
    try:
        await message.reply("",files=avatars)
    except:
        await message.reply("failed!")
    
@addcmd("multicatgif", 1, "multicatgif")
async def multicatgif(msg, message, self):
    msg = await message.channel.send("sending..this may take a minute.. (time depends on internet)")
    cats = []
    i = 0
    while i != 5:
        i = i + 1
        cats.append(await getGif("https://cataas.com/cat/gif"))
    try:
        await message.reply("Meow :cat:!", files=cats)
    except:
        await message.reply("failed")
    await msg.delete()

@addcmd("kill", 1, "kill @someone")
async def kill(msg, message, self):
    for mention in message.mentions:
        if mention.id == message.author.id:
            await message.channel.send(f"<@{mention.id}> but why?")
            continue
        new_msg = await message.channel.send(f"<@{mention.id}>, was killed by <@{message.author.id}>! :gun:")


@addcmd("timestamp", 1, "timestamp")
async def timestamp(msg, message, self):
    unix = str(await tick())
    await message.reply(f"<t:{unix}:R>")
    
@addcmd("watch", 2, "watch")
async def watch(msg, message, self):
    global watching
    channel = message.channel
    await message.edit("watching channel..:eyes:")
    time.sleep(.5)
    await message.delete()
    watching.append(channel)

@addcmd("unwatch", 2, "unwatch")
async def unwatch(msg, message, self):
    global watching
    watching.remove(message.channel)
    await message.edit("no longer watching!")
    time.sleep(2)
    await message.delete()
    
@addcmd("lock", 2, "lock")
async def lock(msg, message, self):
    global others_allowed
    others_allowed = False
    await message.edit("locked! :lock: ")
    time.sleep(2)
    await message.delete()

@addcmd("unlock", 2, "unlock")
async def unlock(msg, message, self):
    global others_allowed
    others_allowed = True
    await message.edit("unlocked! :unlock:")
    time.sleep(2)
    await message.delete()
    

@addcmd("kiss", 1, "kiss @someone")
async def kiss(msg, message, self):
    for mention in message.mentions:
        await message.reply(f"<@{message.author.id}> kisses <@{mention.id}>! :kiss:")
        
@addcmd("hug", 1, "hug @someone")
async def hug(msg, message, self):
    for mention in message.mentions:
        await message.reply(f"<@{message.author.id}> hugs <@{mention.id}>! :people_hugging: ")



@addcmd("ppsize", 1, "ppsize @someone")
async def ppsize(msg, message, self):
    for mention in message.mentions:
        if mention.id == 1195825285866717215:
            size = "infinite"
        else:
            size = str(random.randint(0, 30))
            
        await message.reply(f"<@{mention.id}> has a pp size of " + size + " inches !")
         
         
@addcmd("gaymeter", 1, "gaymeter @someone")
async def gaymeter(msg, message, self):
    for mention in message.mentions:
        if mention.id == 1195825285866717215:
            gay = "0"
        else:
            gay = str(random.randint(0, 100))
            
        await message.reply(f"<@{mention.id}> is " + gay + "% gay!")
        

@addcmd("punch", 1, "punch @someone")
async def punch(msg, message, self):
    for mention in message.mentions:
        await message.reply(f"<@{message.author.id}> punched <@{mention.id}>! :punch:")
        
@addcmd("cmds", 1, "cmds")
async def cmdz(msg, message, self):
   cmdlistt = cmdlist()
   msg = await cmdlistt.start(message.channel)
   
   

@addcmd("whitelist", 2, "whitelist")
async def whitelist(msg, message, self):
    global whitelisted
    whitelisted.append(message.channel)
    await message.edit("channel whitelisted, do cmds to get started!")
    
@addcmd("unwhitelist", 2, "unwhitelist")
async def unwhitelist(msg, message, self):
    global whitelisted
    whitelisted.remove(message.channel)
    await message.edit("unwhitelisted")
    
@addcmd("spamping", 2, "spamping @someone")
async def spamping(msg, message, self):
    global spam_ping
    spam_ping = True
    if len(message.mentions) < 1:
        await message.edit("ping someone")
        time.sleep(2)
        await message.delete()
        return ""
    ping = message.mentions[0].id
    channel = message.channel
    await message.delete()
    while spam_ping == True:
        time.sleep(random.randint(1, 10))
        await channel.send(f"<@{ping}>")
        
@addcmd("unspamping", 2, "unspamping")
async def unspamping(msg, message, self):
    global spam_ping
    spam_ping = False
    await message.edit("turned off!")
    time.sleep(2)
    await message.delete()
    
@addcmd("gamble", 1, "gamble")
async def gamble(msg, message, self):
    num = random.randint(1, 2)
    if num == 1:
        await message.reply("winner!")
    else:
        await message.reply("fucking loser get good")
        
@addcmd("pie", 1, "pie")
async def pie(msg, message, self):
    num = random.randint(1, 2)
    if num == 1:
        await message.reply("eat up :pie:")
    else:
        await message.reply("oven exoloded:boom:")
        
@addcmd("8ball", 1, "8ball")
async def ball(msg, message, self):
    choices = [
    "likey", "outlook bad", "maybe", "yes", "no", "idfk man im js a ball"
    ]
    num = random.randint(0, len(choices)-1)
    await message.reply(choices[num])
        
@addcmd("nuke", 2, "nuke")
async def nuke(msg, message, self):
    await message.edit("woah! this command is dangerous. react :thumbsup: to confirm.")
    passed = await waitForReaction('üëç', bot_runner, message)
    if passed == False:
        await message.edit("command aborted")
        time.sleep(2)
        await message.delete()
        return ""
    await message.delete()
    channels = []
    try:
        channels.append(await message.guild.create_text_channel("ant was here"))
    except:
        await message.channel.send("failed")
        return ""
    i = 0
    while i < 20:
        i = i + 1
        channels.append(await message.guild.create_text_channel("ant was here"))
        time.sleep(.5)
    for channel in channels:
        await channel.send("@everyone")
        
@addcmd("dm", 2, "dm @someone (msg)")
async def dm(msg, message, self):
    mention = message.mentions[0]
    msg.pop(0)
    msg = " ".join(msg)
    await message.delete()
    dm = await self.create_dm(mention)
    await dm.send(msg)
    
    
@addcmd("clone",2, "clone")
async def clone(msg, message, self):
    await message.edit("are you sure react :thumbsup: to confirm.?")
    consent = await waitForReaction('üëç', self.user, message)
    if consent == False:
       await message.delete()
       return ""
    try:
        clone = await message.channel.clone()
        await clone.edit(position=message.channel.position)
        await message.channel.delete()
    except:
        await message.channel.send("failed")
        
        
        
@addcmd("spam", 2, "spam (msg)")
async def spam(msg, message, self):
    global spam_ping
    msg = " ".join(msg)
    spam_ping = True
    channel = message.channel
    await message.delete()
    while spam_ping == True:
        time.sleep(random.randint(1, 3))
        await channel.send(msg)
        
@addcmd("unspam", 2, "unspam")
async def unspam(msg, message, self):
    global spam_ping
    spam_ping = False
    await message.edit("turned off!")
    time.sleep(2)
    await message.delete()


@addcmd("banner", 1, "banner @someone")
async def banners(msg, message, self):
    banners = []
    msg = await message.reply("give us a second!")
    for mention in message.mentions:
        id = mention.id
        mention = await self.fetch_user_profile(mention.id)
        if mention.display_banner == None:
            await message.reply(f"<@{id}> has no display banner")
            continue
        if mention.banner.url.find(".gif"):
            banners.append(await getGif(mention.display_banner.url))
        else:
            bannerds.append(await getImg(mention.display_banner.url))
    await msg.delete()
    try:
        await message.reply("",files=banners)
    except:
        await message.reply("failed!")
        
@addcmd("servericon",1,"servericon") 
async def servericon(msg, message,self):
    msg = await message.reply("give us a second!")
    try:
        if message.channel.guild.icon.url.find(".gif"):
            file = await getGif(message.channel.guild.icon.url)
        else:
            file = await getImg(message.channel.guild.icon.url)
    except:
        await msg.edit("not a guild/no icon!")
        return ""
   